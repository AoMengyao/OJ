### NC1 大数加法

> <font color='black'>**描述**</font>
>
> 以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。
>
> 数据范围：s.length,t.length<=100000，字符串仅由'0'~‘9’构成
>
> 要求：时间复杂度 O(n)<br/>
><font color='black'>**示例1**</font>
>
>```
>输入："1","99"
>返回值："100"
>说明：1+99=100 
>```
>
><font color='black'>**示例2**</font>
>
>```
>输入："114514",""
>返回值："114514"
>```

### NC22 合并两个有序的数组
> <font color='black'>**描述**</font>
> 
> 给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组
>
> 数据范围： 0≤n,m≤100，$|A_i|$ <=100, $|B_i|$ <= 100
>
> <font color='black'>**注意：**</font>
> 
> 1. 保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n
> 
> 2. 不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印
>  
> 3. A 数组在[0,m-1]的范围也是有序的
> 
> <font color='black'>**示例1**</font>
> ```
> 输入：[4,5,6],[1,2,3]
> 返回值：[1,2,3,4,5,6]
> ```
>
> <font color='black'>**说明：**</font>
> 
> A数组为[4,5,6]，B数组为[1,2,3]，
> 
> 后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，
> 
> m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，
> 
> 将B的数据合并A里面，最后后台程序输出A数组
> 
> <font color='black'>**示例2**</font>
> ```
> 输入：[1,2,3],[2,5,6]
> 返回值：[1,2,2,3,5,6]
> ```

### NC32 求平方根

> <font color='black'>**描述**</font>
>
> 实现函数 int sqrt(int x).
> 计算并返回 x 的平方根（向下取整）
>
> 斐波那契数列是一个满足 的数列
>
> 数据范围： 0 <= x < $2^{31}-1$
>
> 要求：空间复杂度 O(1)，时间复杂度 O($logx$)
>
>
> <font color='black'>**示例1**</font>
>
> ```
> 输入：2
> 返回值：1
> ```
> <font color='black'>**示例2**</font>
>
> ```
> 输入：2143195649
> 返回值： 46294
> ```



### NC65 斐波那契数列

> <font color='black'>**描述**</font>
>
> 大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。
>
> 斐波那契数列是一个满足 的数列
>
> 数据范围：
>
> 要求：空间复杂度 O(1)，时间复杂度 O(n) ，本题也有时间复杂度 O(logn)的解法<br/>
>
> <font color='black'>**输入描述：**</font>
>
> 一个正整数n。
>
> <font color='black'>**返回值描述：**</font>
>
> 输出一个正整数。<br/>
> <font color='black'>**示例1**</font>
>
> ```
> 输入：4
> 返回值：3
> 说明：根据斐波那契数列的定义可知，fib(1)=1,fib(2)=1,fib(3)=fib(3-1)+fib(3-2)=2,fib(4)=fib(4-1)+fib(4-2)=3，所以答案为3。   
> ```
> <font color='black'>**示例2**</font>
>
> ```
> 输入：1
> 返回值：1   
> ```
> <font color='black'>**示例3**</font>
>
> ```
> 输入：2
> 返回值：1   
> ```

### NC75 数组中只出现一次的两个数

> <font color='black'>**描述**</font>
>
> 一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
>
> 数据范围：数组长度 2≤n≤1000，数组中每个数的大小 0<val≤1000000
>
> 要求：空间复杂度 O(1)，时间复杂度 O(n)
>
> 提示：输出时按非降序排列。
>
> <font color='black'>**示例1**</font>
> ```
> 输入：>[1,4,1,6]
> 返回值：>[4,6]
> 说明：
> 返回的结果中较小的数排在前面    
> ```
> <font color='black'>**示例2**</font>
> ```
> 输入：>[1,2,3,3,2,9]
> 返回值：>[1,9]
> ```

### NC78 反转链表
> <font color='black'>**描述**</font><br/>
> 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。
> 
> 数据范围：0≤n≤1000
> 要求：空间复杂度O(1) ，时间复杂度O(n) 。
> 
> 如当输入链表{1,2,3}时，
> 经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。
> 以上转换过程如下图所示：
> ![avatar](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)

> <font color='black'>**示例1**</font>
>
> 输入：
> {1,2,3}
>
> 返回值：
> {3,2,1}
>
> <font color='black'>**示例2**</font>
>
> 输入：
> {}
> 
> 返回值：
> {}
> 
> 说明：
> 空链表则输出空    

### NC103 反转字符串



### NC141 判断是否为回文字符串



### NC151 最大公约数
> <font color='black'>**描述**</font>
> 
> 如果有一个自然数 a 能被自然数 b 整除，则称 a 为 b 的倍数， b 为 a 的约数。几个自然数公有的约数，叫做这几个自然数的公约数。公约数中最大的一个公约数，称为这几个自然数的最大公约数。
> 
> 输入 a 和 b , 请返回 a 和 b 的最大公约数。
> 
> 数据范围：1≤a,b≤$10^9$
> 
> 进阶：空间复杂度 O(1)，时间复杂度O($logn$)
> 
> <font color='black'>**示例1**</font>
> ```
> 输入：3,6
> 返回值：3
> ```
> <font color='black'>**示例2**</font>
> 
> ```
> 输入：8,12
> 返回值： 4
> ```
> 
> <font color='black'>**备注：**</font>
> 
> a和b的范围是[1-$10^9$]


### NC288 打印从1到最大的n位数
> <font color='black'>**描述**</font>
> 
> 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
> 1. 用返回一个整数列表来代替打印
> 2. n 为正整数，0 < n <= 5
> 
> <font color='black'>**示例1**</font>
> ```
> 输入：1
> 返回值：[1,2,3,4,5,6,7,8,9]
> ```


### NC298 两个队列实现栈
> <font color='black'>**描述**</font>
> 
> 请你仅使用两个队列实现一个后入先出的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty），输入数据保证 pop、top函数操作时，栈中一定有元素。
> 
> void push(int element) 将元素 element 压入栈顶。
> 
> int pop() 移除并返回栈顶元素。
> 
> int top() 返回栈顶元素。
> 
> bool empty() 如果栈是空的，返回 true ；否则，返回 false 。
> 
> 数据范围：操作数量满足0≤n≤1000，输入的元素满足$∣val∣$≤1000
> 
> <font color='black'>**示例:**</font>
> ```
> 输入:    ["MTY","PSH1","TOP","MTY"]
> 输出:    ["true","1","false"]
> ```
> <font color='black'>**解析:**</font>
> 
> "MTY"表示当前栈是不是为空=>当前为空，返回"true"
> 
> "PSH1"表示将1压入栈中，栈中元素为1
> 
> "TOP"表示获取栈顶元素==>返回"1"
> 
> "MTY"表示当前栈是不是为空=>当前不为空，返回"false"
> 
> <font color='black'>**注意：**</font>
> 1. 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
> 2. 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
> 
> <font color='black'>**示例1**</font>
> ```
> 输入：["MTY","PSH1","TOP","MTY"]
> 返回值：["true","1","false"]
> ```


### NC298 两个队列实现栈
> <font color='black'>**描述**</font>
> 
> 给定一个包含 n 个正整数的数组 nums，数组中所有数字都在区间 [1,n-1] 内，
> 
> 但有一个数出现了两次及以上，其余所有数字都仅出现一次。
> 
> 例如 [4,2,3,1,4] ，其中 4 出现了两次。请你找到这个重复的数。
> 
> 数据范围： 1≤n≤$10^5$ 
> 
> <font color='black'>**示例1**</font>
> ```
> 输入：[4,2,1,3,3]
> 返回值：3
> ```
> <font color='black'>**示例2**</font>
> ```
> 输入：[1,2,3,4,5,6,7,8,9,9]
> 返回值：9
> ```